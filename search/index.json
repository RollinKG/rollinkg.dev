[{"content":"LiveData는 Observable한 데이터 타입입니다. 일반 Observable한 변수와는 다르게 LiveData는 LifeCycle을 인식합니다. 수명주기 인식을 통해 활성 상태 (STARTED, RESUMED) 에 있는 앱 컴포넌트만 업데이트합니다. 따라서 UI와 데이터를 처리할 때 메모리 누수라던지 수명주기로 인한 ANR을 신경쓰지 않아도 됩니다. 또한 MVVM 패턴 및 databinding을 사용하는데 핵심적인 역할을 합니다.\n 1. LiveData 객체 만들기 LiveData는 Generic하게 생성할 수 있어 List와 같은 Collection 및 모든 데이터와 사용할 수 있습니다. 아래 코드는 String 타입의 LiveData를 선언한 코드입니다. 또한 LiveData의 인스턴스는 일반적으로 ViewModel 클래스 내에서 이루어집니다. 그 이유는 Activity와 Fragment는 데이터 표시만 담당하고, 데이터 상태는 ViewModel에 저장하는 일종의 역할 분담이라고 보시면 됩니다. 자세한 구조는 [MVVM 포스트]에 작성하였습니다.\n//문자열 LiveData 선언 //viewmodel.kt val livedata = MutableLiveData\u0026lt;String\u0026gt;() livedata.value = \u0026#34;Hello, World!\u0026#34;  2. LiveData 객체 Observe LiveData의 변화를 감지하는 방법에는 두가지가 있습니다. 2번 항목은 Databinding 라이브러리 활용이므로 MVVM + Databinding 포스트에 자세하게 작성하였습니다. 이번 포스트에서는 1번 항목만 다루겠습니다.\n  Activity, Fragment에서 Observer로 관찰\n  Databinding으로 xml view 요소를 직접 LiveData와 바인딩\n  아래는 Activity의 onCreate 내부에 Observer를 생성하여 viewmodel의 LiveData를 관찰하는 코드입니다.\noverride fun onCreate{ viewmodel.livedata.observe(this, Observer{ it -\u0026gt; //LiveData의 변화가 감지되면 이 코드블럭이 실행된다  textView.text = it }) } 여기서 주의깊게 보셔야할 점은 첫번째 인자로 전달된 this 입니다. 여기서 this는 context나 activity가 아닌 lifecycleowner로써 전달되는 인자입니다. LiveData는 수명주기를 인식하므로, LiveData에게 수명주기를 제공할 객체를 전달하는 것입니다. Fragment에서 Observer를 등록하는 경우 this가 아닌 lifecycleowner를 전달해야 합니다.\n 3. LiveData 확장 LiveData를 사용하다보면 저장된 값을 변경하거나 다른 방식으로 보여주고 싶을 때가 있습니다. 예를들어 서버에서 raw하게 넘어온 문자열을 파싱하거나 사용자에게 보기 좋도록 표시할때, LiveData의 Transform 클래스를 이용하면 됩니다.\n1) map() map()은 LiveData에 저장된 값에 함수를 적용하여 값을 반환합니다.\nval userLiveData: LiveData\u0026lt;User\u0026gt; = UserLiveData() val userName: LiveData\u0026lt;String\u0026gt; = Transformations.map(userLiveData) { user -\u0026gt; \u0026#34;${user.name}님 환영합니다!\u0026#34; } 2) switchMap() map()과 유사하나 메소드의 리턴 타입이 값이 아닌 LiveData 타입을 반환해야합니다.\nprivate fun getUser(id: String): LiveData\u0026lt;User\u0026gt; { val liveData: MutableLiveData\u0026lt;String\u0026gt; = MutableLiveData() liveData.apply{ value = \u0026#34;${id}님 환영합니다!\u0026#34; } return liveData } val userId: LiveData\u0026lt;String\u0026gt; = ... val user = Transformations.switchMap(userId) { id -\u0026gt; getUser(id) }  Reference\n https://developer.android.com/topic/libraries/architecture/livedata?hl=ko ","date":"2020-09-08T00:00:00Z","permalink":"rollinkg.github.io/p/android-livedata-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/","title":"Android LiveData 알아보기"},{"content":"Android UI 오픈소스 MPAndroidChart는 쉽고 다양한 기능을 제공하는 오픈소스 차트 라이브러리입니다. 선, 막대, 파이, 버블 등 다양한 형태와 애니메이션까지 함께 지원하여 간단하게 안드로이드 앱에 시각적 차트 데이터를 삽입할 수 있습니다.\n이번 포스트에서는 Pie Chart(파이 그래프) 의 기본적인 사용법을 알아보겠습니다.\n 1. Import MPAndroidChart 다음 MPAndroidChart 링크에 들어가 최신 버전을 확인하고, Gradle에 다음 의존성을 추가합니다.\ndependencies { ... implementation \u0026#39;com.github.PhilJay:MPAndroidChart:v3.1.0\u0026#39; ... } 이후 Gradle Sync 해주시면 MPAndroidChart를 사용할 준비는 끝났습니다.\n 2. PieChart View 추가 원하는 xml 레이아웃에 com.github.mikephil.charting.charts.PieChart를 추가하고 배치합니다. layout_height 의 경우 match_parent 혹은 wrap_content 로 지정해 줄 경우, 차트가 보이지 않을 수 있습니다. 되도록이면 고정된 값으로 높이를 설정하는 걸 추천드립니다.\n\u0026lt;com.github.mikephil.charting.charts.PieChart android:id=\u0026#34;@+id/pie_chart\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; /\u0026gt;  3. PieChart 코드 작성 Activity나 Fragment에서 코드를 작성하여 차트를 초기화하는 과정입니다. 여러 클래스를 사용하기 때문에 제일 헷갈리는 부분입니다. 다음과 같은 데이터를 작성해야 합니다.\n  PieEntry  PieDataSet  PieData  위 순서대로 자세한 용도와 작성법을 설명드리겠습니다.\n1) PieEntry PieEntry에는 (value, label) 쌍으로 Bar Chart에 표시될 데이터를 저장합니다. 원하는 데이터를 PieEntry로 만든 뒤, 이를 담는 리스트를 선언하여 추가하면 됩니다. PieEntry에 들어가는 value는 기본적으로 float입니다. 이를 Int나 원하는 String으로 바꾸고 싶은 경우 추후에 label 을 다는 작업을 거쳐야 합니다.\n//PieEntry를 담는 리스트 val entryList = mutableListOf\u0026lt;PieEntry\u0026gt;() //PieEntry로 값 추가 후 리스트에 담는다 entryList.add(PieEntry(5f,\u0026#34;A\u0026#34;)) entryList.add(PieEntry(2f,\u0026#34;B\u0026#34;)) entryList.add(PieEntry(2f,\u0026#34;C\u0026#34;)) 2) PieDataSet PieDataSet 은 위에 작성된 PieEntry 를 바탕으로 실제 Pie data set 를 생성합니다. 단순 데이터인 PieEntry 를 파이 모양으로 표시하기 위해 반드시 필요하며, 파이의 두께, 색, 텍스트 위치 등 다양한 설정을 할 수 있습니다.\n//위에서 만든 PieEntry 리스트를 인자로 준다 val pieDataSet = PieDataSet(entryList,\u0026#34;MyPieChart\u0026#34;) //example //다음과 같이 Pie 커스터마이징이 가능하다 pieDataSet.apply { //슬라이스 간격  sliceSpace = 2f selectionShift = 5f //슬라이스 색, 미리 정의하거나 resource로 가져온 색 리스트를 줘도 좋다  colors = chartColors //value 위치, 크기 지정  yValuePosition=PieDataSet.ValuePosition.OUTSIDE_SLICE valueTextSize = 11f } 3) PieData 마지막으로 PieChart에 보여질 데이터를 구성합니다.\nval pieData = PieData(pieDataSet) PieDataSet과 마찬가지로 다양한 차트 커스터마이징 메소드를 제공합니다.\n4) PieChart xml에서 추가한 PieChart의 객체를 선언하여, 위 과정을 통해 최종적으로 만들어진 PieData를 건내주면 파이 그래프를 보여주기 위한 설정은 끝입니다. 아래 코드는 binding 객체를 통하여 pieChart에 접근합니다. 사용하는 라이브러리에 따라 findViewById 혹은 Kotlin Synthetic을 통해 어떠한 방법으로든 전달하시면됩니다.\n//binding으로 접근하여 pieData 전달 val pieChart = binding.pieChart pieChart.data = pieData //pieChart 갱신하여 데이터 표시 pieChart.invalidate() 위 과정을 마치면 성공적으로 차트가 그려진 것을 확인할 수 있다.\n 4. PieChart 설정 예제 MPAndroidChart는 바 색상, 텍스트, 애니메이션, 범례 등 다양한 부분의 커스터마이징이 가능합니다. 그 말인 즉슨, 내가 원하는 방식으로 차트를 보여주려면 꽤 많은 부분을 만져야합니다. 아래 코드는 PieChart에서 자주 사용되는 설정 예제입니다. 물론 아래 코드보다 훨씬 많은 기능을 제공하므로 모든 기능을 살표보시려면 MPAndroidChart Github를 방문해보는걸 추천드립니다.\npieChart.apply{ //Chart가 그려질때 애니메이션  animateY(1000, Easing.EaseOutCubic) //Chart 밑에 description 표시 유무  description=null //파이 차트 가운데 빈 구멍, 텍스트 설정  holeRadius=55f centerText=\u0026#34;나의 파이차트\u0026#34; setCenterTextSize(13f) //Legend는 차트의 범례를 의미합니다  //범례가 표시될 위치를 설정  legend.verticalAlignment = Legend.LegendVerticalAlignment.TOP legend.horizontalAlignment = Legend.LegendHorizontalAlignment.LEFT //label 텍스트 크기, 색  setEntryLabelTextSize(11f) setEntryLabelColor(Color.BLACK) } 1) value에 Float이 아닌 원하는 String 설정하기 기본적으로 PieEntry의 value 는 float을 인자로 받습니다. 이를 float값이 아니라 사용자 정의 값을 넣고싶은 경우 (e.g 2f를 2개로 표시) . PieEntry의 x값을 파싱하여 valueFormatter에서 return하면 됩니다.\n//valueFormatter은 PieDataSet에서 설정하시면 됩니다.  valueFormatter = object: ValueFormatter(){ override fun getFormattedValue(value: Float): String { return value.toInt().toString() + \u0026#34;개\u0026#34; } }  Reference\n https://github.com/PhilJay/MPAndroidChart ","date":"2020-07-21T00:00:00Z","image":"/rollinkg.github.io/p/android-studio-mpandroidchart-%ED%8C%8C%EC%9D%B4-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"rollinkg.github.io/p/android-studio-mpandroidchart-%ED%8C%8C%EC%9D%B4-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","title":"Android Studio MPAndroidChart 파이 그래프 사용하기"},{"content":"Android UI 오픈소스 MPAndroidChart는 쉽고 다양한 기능을 제공하는 오픈소스 차트 라이브러리입니다. 선, 막대, 파이, 버블 등 다양한 형태와 애니메이션까지 함께 지원하여 간단하게 안드로이드 앱에 시각적 차트 데이터를 삽입할 수 있습니다.\n이번 포스트에서는 Bar Chart(막대 그래프) 의 기본적인 사용법을 알아보겠습니다.\n 1. Import MPAndroidChart 다음 MPAndroidChart 링크에 들어가 최신 버전을 확인하고, Gradle에 다음 의존성을 추가합니다.\ndependencies { ... implementation \u0026#39;com.github.PhilJay:MPAndroidChart:v3.1.0\u0026#39; ... } 이후 Gradle Sync 해주시면 MPAndroidChart를 사용할 준비는 끝났습니다.\n 2. BarChart View 추가 원하는 xml 레이아웃에 com.github.mikephil.charting.charts.BarChart를 추가하고 배치합니다. layout_height 의 경우 match_parent 혹은 wrap_content 로 지정해 줄 경우, 차트가 보이지 않을 수 있습니다. 되도록이면 고정된 값으로 높이를 설정하는 걸 추천드립니다.\n\u0026lt;com.github.mikephil.charting.charts.BarChart android:id=\u0026#34;@+id/bar_chart\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; /\u0026gt;  3. BarChart 코드 작성 Activity나 Fragment에서 코드를 작성하여 차트를 초기화하는 과정입니다. 여러 클래스를 사용하기 때문에 제일 헷갈리는 부분입니다. 다음과 같은 데이터를 작성해야 합니다.\n  BarEntry  BarDataSet  BarData  위 순서대로 자세한 용도와 작성법을 설명드리겠습니다.\n1) BarEntry BarEntry에는 (x, y) 쌍으로 Bar Chart에 표시될 데이터를 저장합니다. 원하는 데이터를 BarEntry로 만든 뒤, 이를 담는 리스트를 선언하여 추가하면 됩니다. BarEntry에 들어가는 값은 기본적으로 float입니다. 이를 Int나 원하는 String으로 바꾸고 싶은 경우 추후에 label 을 다는 작업을 거쳐야 합니다.\n//BarEntry를 담는 리스트 val entryList = mutableListOf\u0026lt;BarEntry\u0026gt;() //BarEntry로 값 추가 후 리스트에 담는다 entryList.add(BarEntry(0f,1f)) entryList.add(BarEntry(1f,5f)) entryList.add(BarEntry(2f,0f)) 2) BarDataSet BarDataSet 은 위에 작성된 BarEntry 를 바탕으로 실제 Bar data set 를 생성합니다. 단순 데이터인 BarEntry 를 막대 모양으로 표시하기 위해 반드시 필요하며, 막대의 두께, 색, 테두리 등 다양한 설정을 할 수 있습니다.\n//위에서 만든 BarEntry 리스트를 인자로 준다 val barDataSet = BarDataSet(entryList, \u0026#34;MyBarDataSet\u0026#34;) //example //다음과 같이 Bar 커스터마이징이 가능하다 bardataSet.color = ColorTemplate.rgb(\u0026#34;#ff7b22\u0026#34;) 3) BarData 마지막으로 BarChart에 보여질 데이터를 구성합니다. 하나의 BarData에는 여러 개의 BarDataSet이 있을 수 있습니다. 한 차트에서 여러 막대 그래프를 함께 보여주기 위한 목적이라고 보시면 됩니다. 또한 여러 개의 BarDataSet을 효율적으로 보여주기 위한 barWidth, groubBar와 같은 변수, 메소드를 제공합니다.\n// , 구분으로 여러 BarDataSet을 줄 수 있습니다. val barData = BarData(barDataSet) //example //BarData에 추가된 모든 BarDataSet에 일괄 적용되는 값입니다. barData.barWidth = 0.35f 여러 바를 보여주고 싶다면 BarData() 인자에 쉼표 구분으로 여러 BarDataSet을 전달하면 됩니다.\n4) BarChart xml에서 추가한 BarChart의 객체를 선언하여, 위 과정을 통해 최종적으로 만들어진 BarData를 건내주면 막대 그래프를 보여주기 위한 설정은 끝입니다. 아래 코드는 binding 객체를 통하여 barChart에 접근합니다. 사용하는 라이브러리에 따라 findViewById 혹은 Kotlin Synthetic을 통해 어떠한 방법으로든 전달하시면됩니다.\n//binding으로 접근하여 barData 전달 val barChart = binding.barChart barChart.data = barData //barChart 갱신하여 데이터 표시 barChart.invalidate() 위 과정을 마치면 성공적으로 차트가 그려진 것을 확인할 수 있다.\n 4. BarChart 설정 예제 MPAndroidChart는 바 색상, 텍스트, 애니메이션, 범례 등 다양한 부분의 커스터마이징이 가능합니다. 그 말인 즉슨, 내가 원하는 방식으로 차트를 보여주려면 꽤 많은 부분을 만져야합니다. 아래 코드는 BarChart에서 자주 사용되는 설정 예제입니다. 물론 아래 코드보다 훨씬 많은 기능을 제공하므로 모든 기능을 살표보시려면 MPAndroidChart Github를 방문해보는걸 추천드립니다.\nbarChart.apply { //터치, Pinch 상호작용  setScaleEnabled(false) setPinchZoom(false) //Chart가 그려질때 애니메이션  animateXY(0,800) //Chart 밑에 description 표시 유무  description=null //Legend는 차트의 범례를 의미합니다  //범례가 표시될 위치를 설정  legend.verticalAlignment = Legend.LegendVerticalAlignment.TOP legend.horizontalAlignment = Legend.LegendHorizontalAlignment.LEFT //차트의 좌, 우측 최소/최대값을 설정합니다.  //차트 제일 밑이 0부터 시작하고 싶은 경우 설정합니다.  axisLeft.axisMinimum = 0f axisRight.axisMinimum = 0f //기본적으로 차트 우측 축에도 데이터가 표시됩니다  //이를 활성화/비활성화 하기 위함  axisRight.setDrawLabels(false) //xAxis, yAxis 둘다 존재하여 따로 설정이 가능합니다  //차트 내부에 Grid 표시 유무  xAxis.setDrawGridLines(false) //x축 데이터 표시 위치  xAxis.position = XAxis.XAxisPosition.BOTTOM //x축 데이터 갯수 설정  xAxis.labelCount = entry.size } 1) X축에 Float이 아닌 원하는 String 설정하기 기본적으로 BarEntry 는 float을 인자로 받습니다. 이를 float값이 아니라 사용자 정의 값을 넣고싶은 경우 (e.g 월, 화, 수, 목, 금..) . BarEntry의 x값을 0.0 , 1.0 과 같이 추후에 Int로 파싱하여 index로 활용할 수 있도록 줍니다. 그리고 다음과 같이 원하는 label를 정의합니다.\nval labels = arrayof(\u0026#34;월\u0026#34;, \u0026#34;화\u0026#34;, \u0026#34;수\u0026#34;) 그리고 BarChart에서 valueFormatter로 x값을 label에 매칭시켜주면 됩니다.\nbarChart.xAxis.valueFormatter = object: ValueFormatter() { override fun getFormattedValue(value: Float): String { return labels[value.toInt()] } } 위 코드의 return 부분을 수정하여 비단 String뿐만이 아닌 다양하게 x축의 label을 설정할 수 있습니다.\n Reference\n https://github.com/PhilJay/MPAndroidChart ","date":"2020-07-03T00:00:00Z","image":"/rollinkg.github.io/p/android-studio-mpandroidchart-%EB%A7%89%EB%8C%80-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"rollinkg.github.io/p/android-studio-mpandroidchart-%EB%A7%89%EB%8C%80-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","title":"Android Studio MPAndroidChart 막대 그래프 사용하기"},{"content":"Room은 SQLite에 대한 추상화 레이어를 제공하여 로컬 데이터베이스 사용을 원할하게 합니다. Android는 SQLite 대신 Room을 사용할 것을 적극적으로 권장 하며, Room을 사용하여 상당한 양의 앱 데이터를 구조화된 형태로 로컬에 저장할 수 있습니다.\n 1. Room Import 앱 단위 Gradle 최상단에 kapt 플러그인을 적용합니다. kapt란 Kotlin Annotation Processing Tool의 줄임말로, 코틀린 환경에서 annotation 코드 블럭을 컴파일 하기 위하여 필요합니다.\napply plugin: \u0026#39;kotlin-kapt\u0026#39; 다음으로 Room 라이브러리 의존성을 추가하고 Graadle Sync하여 프로젝트에 동기화 합니다.\ndependencies{ ... implementation \u0026#39;androidx.room:room-runtime:2.2.5\u0026#39; kapt \u0026#39;androidx.room:room-compiler:2.2.5\u0026#39; // optional - Kotlin Extensions and Coroutines support for Room implementation \u0026#34;androidx.room:room-ktx:2.2.5\u0026#34; }  2. Room 클래스 정의 Room은 기본적으로 테이블 형식으로 데이터를 관리하며, 사용하기 위해선 다음 3가지 구성요소를 작성해야합니다. 자세한 내용은 아래 항목에 예제 코드와 함께 작성하였습니다.\n Data Entity: data class로 작성하며, DB의 스키마, 테이블을 정의 DAO: DB에 엑세스 하는 메소드가 포함 Database: DB의 기본 엑세스 포인트  1) Data Entity User.kt\n@Entity data class User( @PrimaryKey val uid: Int, @ColumnInfo(name = \u0026#34;first_name\u0026#34;) val firstName: String?, @ColumnInfo(name = \u0026#34;last_name\u0026#34;) val lastName: String? ) 첫번째로 Data Entity입니다. 원하는 data Class를 @Entity 어노테이션으로 감싸 작성합니다. 내부에는 기존 data class 사용과 동일하게 원하는 데이터와 타입을 명시해주면 됩니다. 이때 반드시 @PrimaryKey를 통해 테이블의 키를 명시해주어야 합니다.\n또한 Primary Key를 자동으로 증가하는 인덱스로 하고 싶은 경우가 있을 수 있습니다. 이런 경우엔 아래 코드와 같이 autoGenerate = true를 주시고 후에 값으로 0 or null을 주시면 자동으로 인덱스가 생성되어 저장됩니다.\n@PrimaryKey(autoGenerate = true) val uid: Int 2) DAO UserDao.kt\n@Dao interface UserDao { @Query(\u0026#34;SELECT * FROM user\u0026#34;) fun getAll(): List\u0026lt;User\u0026gt; @Query(\u0026#34;SELECT * FROM user WHERE uid IN (:userIds)\u0026#34;) fun loadAllByIds(userIds: IntArray): List\u0026lt;User\u0026gt; @Query(\u0026#34;SELECT * FROM user WHERE first_name LIKE :first AND \u0026#34; + \u0026#34;last_name LIKE :last LIMIT 1\u0026#34;) fun findByName(first: String, last: String): User @Insert fun insertAll(vararg users: User) @Delete fun delete(user: User) } 다음은 DAO로 내부에 DB에 사용할 쿼리를 메소드로 정의합니다. interface로 작성하며 @Dao 어노테이션으로 감싸 작성합니다. @Insert, @Delete 와 같은 기본적인 쿼리는 기본적으로 제공되며, 그 외의 복잡한 쿼리는 직접 @Query 어노테이션 내부에 작성하고 쿼리를 호출할 메소드를 지정해주어야 합니다. 위 코드는 다양한 DAO 쿼리/메소드 예제입니다. 원하는 값을 전달하여 필터링하는 쿼리를 던지고 싶은경우, 메소드에 파라미터를 지정하고 @Query내부에서 : prefix를 통해 파라미터를 참조할 수 있습니다.\n3) Database UserDatabase.kt\n@Database(entities = [User::class], version = 1, exportSchema = false) abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao companion object{ private var instance : UserDatabase? = null @Synchronized fun getInstance(context : Context) : UserDatabase? { if (instance == null){ instance = Room.databaseBuilder(context.applicationContext, UserDatabase::class.java, \u0026#34;database_name\u0026#34;) .fallbackToDestructiveMigration() .allowMainThreadQueries() .build() } return instance } } } 마지막으로 Database를 생성하고 접근하는 객체입니다. RoomDatabase를 상속하며 @Database 어노테이션으로 감싸 작성합니다. 어노테이션에는 Entity로 사용할 클래스와, DB 버전 등을 명시합니다. 그리고 내부에는 위에 작성한 UserDao를 선언하여 후에 DAO에 접근하여 작성한 메소드를 호출하는 방식을 사용합니다.\n또한 어플리케이션 전체에서 DB에 접근하는 객체는 둘 이상 필요하지 않으므로 내부에 companion object와 Synchronized 키워드를 이용하여 database를 Singletone으로 사용합니다.\n 3. 작성한 Room Database 사용 위 과정을 모두 마쳤다면 이제 Room Database를 사용할 준비는 끝났습니다. 원하는 진입점에서 아래 코드를 이용하여 DB, DAO에 접근하면 됩니다.\nval database = UserDatabase.getInstance(application)!! val userDao = database.userDao() val data = userDao.getAll() DB에 접근하는 행위를 MainThread에서 돌린다면 오랫동안 UI를 잠글 수 있으므로 권장하지 않습니다. 따라서 Corourtine이나 RxJava를 활용한 방식을 추천합니다. 또한 LiveData를 이용하여 DB가 갱신되면 앱 UI가 자동으로 업데이트 되도록 구성할 수 있습니다. 이는 추후 포스트로 작성하겠습니다.\n Reference\n https://developer.android.com/training/data-storage/room?hl=ko ","date":"2020-06-17T00:00:00Z","image":"/rollinkg.github.io/p/android-sqlite-%EC%B6%94%EC%83%81%ED%99%94-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-room-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/luca-bravo-alS7ewQ41M8-unsplash_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"rollinkg.github.io/p/android-sqlite-%EC%B6%94%EC%83%81%ED%99%94-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-room-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","title":"Android SQLite 추상화 라이브러리 Room 사용하기"},{"content":"MVVM 패턴이란, 기존의 MVP패턴에서 View와 Presenter가 가지는 의존성을 없애기 위한 고안된 방식입니다. Presentation 로직은 똑같이 ViewModel에서 이루어지지만, 다른 점은 ViewModel은 View의 존재를 모릅니다. 기존의 Presenter은 관련 로직을 처리하고 UI를 갱신하는 메소드를 인터페이스로 작성하여 View에 넘겨주어야 했지만, MVVM 패턴에서는 이런 과정이 없어진것이죠. 그 대신 View에서는 갱신되어야 하는 UI가 Databinding으로 ViewModel의 값에 바인드되어 있습니다. 따라서 ViewModel에서의 값이 바뀌면 View의 UI 요소가 자동으로 갱신됩니다. 이런 방식으로 View와 ViewModel의 의존성을 없애고 Android MVVM 패턴을 구현할 수 있습니다.\n\r\n 1. ViewModel MVVM 패턴을 적용하기전에, ViewModel에 대한 이해가 필요합니다. 지금 적용하려는 MVVM 패턴의 ViewModel과, AAC의 ViewModel은 엄연히 다른 개념이기 때문입니다. 구글 공식 문서에는 ViewModel을 다음과 같이 설명하고 있습니다.\nViewModel 클래스는 수명 주기를 고려하여 UI 관련 데이터를 저장하고 관리하도록 설계되었습니다. ViewModel 클래스를 사용하면 화면 회전과 같이 구성을 변경할 때도 데이터를 유지할 수 있습니다.\n제가 위에서 설명한 MVVM의 ViewModel과는 좀 다른 개념이죠? AAC의 ViewModel이란, 화면을 회전하는 등의 동작에서 LifeCycle에 의하여 View에 작성되어있는 데이터의 소멸, 메모리 누수등의 문제로 UI를 다루는 로직에서 View의 데이터 소유권을 분리하는 방식입니다. View는 생명주기에 의하여 쉽게 데이터가 바뀌므로, 다양한 환경에서도 일관된 데이터를 유지하겠다는 목적이죠.\n근데 왜 구분을 안하고 사용할까?\n많은 MVVM 예제나, 심지어 안드로이드 공식 문서에서도 AAC ViewModel과 MVVM ViewModel을 크게 구분하여 사용하지 않습니다. 왜냐면 ViewModel 클래스가 두 개의 역할을 다 하고있기 때문입니다. 자연스럽게 MVVM 패턴의 ViewModel에 AAC ViewModel의 기능도 함께 사용하고 있는것이죠. 아래 내용도 둘을 크게 구분하지 않고 코드 예제로 MVVM 패턴을 적용하는 법을 작성할 것입니다. 또한 추후에 앱의 아키텍처를 설계할 일이 생겼을 때, 위 개념을 자세히 알아두는 것이 클린 아키텍처 설계에 분명 도움이 될 것입니다.\n 2. ViewModel 클래스 작성하기 MVVM에서 View의 역할은 Activity, Fragment 가 하고 있으니 핵심적인 ViewModel 클래스를 작성합니다. 필수적으로 LifeCycle 라이브러리의 ViewModel()을 상속하며, 추후 데이터 바인딩을 위해 필요한 변수는 LiveData로 선언합니다. LiveData의 개념과 사용법은 여기에 작성되어있습니다.\nMyViewModel.kt class MyViewModel : ViewModel() { ... val myText = MutableLiveData\u0026lt;String\u0026gt;() ... }\n 3. Databinding 으로 ViewModel과 UI 바인딩 1) 프로젝트에 Databinding 사용 app단위 Gradle에 다음 설정을 추가합니다.\nandroid { ... buildFeatures{ dataBinding = true } ... } 2) Databinding Layout으로 변환 databinding을 적용할 layout xml 루트에 ALT+ENTER를 눌러 convert to databinding layout을 클릭합니다.\n\r\n그럼 layout xml이 다음과 같이 변환됩니다. 기존 View와 추후에 추가할 View들은 \u0026lt;layout\u0026gt; 내부로 들어간 루트 뷰에 작성하면 됩니다.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout\u0026gt; ... \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;/layout\u0026gt; 3) Databinding data 선언 \u0026lt;data\u0026gt; 태그 내부에 사용하고 싶은 data를 변수처럼 선언할 수 있습니다. 이번 포스트에서는 ViewModel의 값과 바인딩을 할 것이기 때문에 ViewModel을 작성하도록 하겠습니다. \u0026lt;variable\u0026gt;태그 내부에 변수 이름과 타입을 다음과 같이 명시합니다. \u0026lt;type\u0026gt;의 경우 프로젝트 패키지명을 포함하여 클래스 명까지 적어주어야 합니다.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;data\u0026gt; \u0026lt;variable name=\u0026#34;vm\u0026#34; type=\u0026#34;com.example.project.MyViewModel\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout\u0026gt; ... \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;/layout\u0026gt; 4) 원하는 UI 요소 바인딩 다음으로 원하는 UI와 ViewModel의 값을 바인딩합니다. @{} 내부에 \u0026lt;data\u0026gt;에 선언해두었던 변수 명으로 접근이 가능합니다. 아래 코드는 TextView를 MyViewModel.kt 에 선언되어있는 LiveData인 myText와 바인딩하는 예제입니다.\n... \u0026lt;Textview\u0026gt; android:width=\u0026#34;wrap_content\u0026#34; andriod:height=\u0026#34;wrap_content\u0026#34; andriod:text=\u0026#34;@{vm.myText}\u0026#34;  3. View에서 Databinding 설정 위 과정을 마쳤다면, View단에서 databinding 설정을 해주어야합니다. layout xml을 databing으로 변환했다면, 자동으로 databinding 클래스가 생성됩니다. 이를 이용하여 View에서 layout을 inflate하고 내부 view 객체에 접근합니다. 이때 생성되는 databinding 클래스는 xml 파일명을 카멜 표기법으로 변환한 이름으로 생성됩니다.\n 1) binding 객체 선언 아래 코드와 같이 lateinit 태그로 바인딩 객체를 생성합니다\nlateinit var binding : ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { ... } 2) DatabindingUtil로 레이아웃 inflate setContentView를 다음 예제와 같이 변경하여 호출합니다.\nlateinit var binding : ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { ... binding = DataBindingUtil.setContentView(this, R.layout.activity_main) } 3) ViewModel 생성 마지막으로 View에서 ViewModel 객체를 생성합니다. 중요한점은 ViewModel은 일반 객체처럼 생성하면 안됩니다. 위 ViewModel의 개념에서 설명한 것처럼, 일반 객체처럼 생성할 경우 화면 전환에 따라 여러개의 ViewModel이 생성되거나 메모리 누수등의 문제가 발생할 수 있습니다. 따라서 ViewModelProvider를 통해 생성하거나 koin 내부 라이브러리 등 뷰모델 주입 메소드를 통해 생성하는 것을 권장합니다.\nMainActivity.kt\nprivate lateinit var viewModel : MyViewModel override fun onCreate(savedInstanceState: Bundle?) { ... viewModel = ViewModelProvider(this, ViewModelProvider.NewInstanceFactory()).get(MyViewModel::class.java) ... } 4) XML data로 ViewModel 전달 마지막으로 xml에 \u0026lt;data\u0026gt;태그로 선언했던 vm 값에 실제 ViewModel을 넘겨주어야 합니다. xml 내부 \u0026lt;data\u0026gt;, \u0026lt;view\u0026gt; 는 binding 객체로 접근할 수 있습니다.\nbinding.vm = viewModel 5) Lifecycler Owner 전달 마지막으로 LifeCyleOwner를 전달합니다. ViewModel 내부 LiveData는 LifeCycler에 의존적이기 때문에 LifeCycleOwner를 전달하지 않으면 실시간 UI 갱신이 일어나지 않습니다.\n//Activity binding.lifecycleOwner = this@MainActivity //Fragment binding.lifecycleOwner = viewLifecycleOwner  4. 마무리 위 작업을 모두 마쳤으면 MVVM + Databinding 사용 준비는 끝났습니다. ViewModel에서 bind된 LiveData의 value가 변할 경우, textView가 자동으로 갱신되는 것을 확인 할 수 있습니다.\n Reference\n https://developer.android.com/topic/libraries/architecture/viewmodel?hl=ko ","date":"2020-03-12T00:00:00Z","image":"/rollinkg.github.io/p/android-studio-databinding%EC%9C%BC%EB%A1%9C-mvvm-%ED%8C%A8%ED%84%B4-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"rollinkg.github.io/p/android-studio-databinding%EC%9C%BC%EB%A1%9C-mvvm-%ED%8C%A8%ED%84%B4-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/","title":"Android Studio Databinding으로 MVVM 패턴 적용하기"}]